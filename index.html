<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat (Customer)</title>

  <style>
    :root{
      --bg: #efeae2;
      --panel: #ffffff;
      --text: #111;
      --muted: #667085;
      --me: #dcf8c6;
      --them: #ffffff;
      --border: #e5e7eb;
      --accent: #25d366;
      --btn: #0b74ff;
      --danger: #ef4444;
    }

    body{ margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #chat{ height: 100dvh; display: flex; flex-direction: column; }

    #topbar{
      padding: 10px 12px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    #status{ font-size: 13px; color: var(--muted); }
    #topActions{ display: inline-flex; align-items: center; gap: 8px; flex: 0 0 auto; white-space: nowrap; }

    #messages{
      flex: 1;
      overflow-y: auto;
      padding: 14px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .bubble{
      max-width: 72%;
      padding: 10px 12px;
      border-radius: 14px;
      line-height: 1.3;
      word-wrap: break-word;
      box-shadow: 0 1px 0 rgba(0,0,0,.06);
      box-sizing: border-box;
    }
    .bubble.me{ align-self: flex-end; background: var(--me); border-top-right-radius: 6px; }
    .bubble.them{ align-self: flex-start; background: var(--them); border-top-left-radius: 6px; }

    .meta{ margin-top: 6px; font-size: 11px; color: rgba(0,0,0,.55); text-align: right; user-select: none; }
    .title{ font-size: 12px; color: var(--muted); margin-bottom: 6px; user-select: none; }

    .group{ display: inline-block; max-width: 72%; }
    .group.me{ align-self: flex-end; }
    .group.them{ align-self: flex-start; }
    .bubble.inGroup{ max-width: 100%; width: 100%; box-sizing: border-box; }
    .group .bubble.inGroup{ margin: 0; }
    .group .bubble.inGroup + .bubble.inGroup{ margin-top: 2px; box-shadow: none; }

    .group.me .bubble.inGroup:first-child{ border-bottom-right-radius: 6px; }
    .group.me .bubble.inGroup:last-child{  border-top-right-radius: 6px; }
    .group.them .bubble.inGroup:first-child{ border-bottom-left-radius: 6px; }
    .group.them .bubble.inGroup:last-child{  border-top-left-radius: 6px; }

    audio{ width: 320px; max-width: 100%; height: 36px; display: block; }

    .tx > summary{
      cursor: pointer;
      user-select: none;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      list-style: none;
    }
    .tx > summary::-webkit-details-marker{ display: none; }
    .tx > summary::before{ content: "â–¸"; display: inline-block; transition: transform 0.12s ease; }
    .tx[open] > summary::before{ transform: rotate(90deg); }
    .transcript{ margin-top: 6px; white-space: pre-wrap; }

    .iconBtn{
      width: 40px; height: 40px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      line-height: 1;
      user-select: none;
      flex: 0 0 auto;
      color: #fff;
    }
    #uploadBtn{ background: var(--btn); }
    #send{ background: var(--accent); }
    #answerBtn{ background: #111827; }
    #hangupBtn{ background: var(--danger); }
    .iconBtn:disabled{ opacity: 0.6; cursor: not-allowed; }

    #composer{
      padding: 10px;
      background: var(--panel);
      border-top: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }

    #msg{
      flex: 1 1 auto;
      min-width: 0;
      font-size: 15px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 999px;
      outline: none;
    }

    #file{ position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0.01; }
    #callState{ font-size: 12px; color: var(--muted); user-select: none; }

    .emailCard .kv{ font-size:12px; color: var(--muted); margin-top:6px; }
    .emailCard .kv div{ margin-top:2px; }

    @media (max-width: 520px){
      #messages{ padding: 10px 8px; gap: 6px; }
      .bubble{ max-width: 92%; }
      .group{ max-width: 92%; }
      .iconBtn{ width: 38px; height: 38px; }
      #topbar{ gap: 8px; }
      #topActions{ gap: 6px; }
    }
  </style>
</head>

<body>
  <div id="chat">
    <div id="topbar">
      <div>
        <div style="font-weight:700">Chat</div>
        <div id="status">Disconnected</div>
        <div id="callState">No call</div>
      </div>

      <div id="topActions">
        <div style="font-size:12px;color:var(--muted)">
          Room: <span id="roomLabel"></span> | Role: <span id="roleLabel"></span>
        </div>
        <button id="answerBtn" class="iconBtn" title="Answer" disabled>âœ”</button>
        <button id="hangupBtn" class="iconBtn" title="Hang up" disabled>âœ•</button>
      </div>
    </div>

    <div id="messages" aria-live="polite"></div>

    <div id="composer">
      <input id="msg" placeholder="Type a messageâ€¦" autocomplete="off" />
      <input id="file" type="file" />
      <button id="uploadBtn" class="iconBtn" title="Upload">ðŸ“Ž</button>
      <button id="send" class="iconBtn" title="Send">âž¤</button>
    </div>

    <audio id="remoteAudio" autoplay></audio>
  </div>

  <script src="https://natisha-flamy-lonely.ngrok-free.dev/socket.io/socket.io.js"></script>

  <script>
    const BASE_URL = "https://natisha-flamy-lonely.ngrok-free.dev";
    const SERVER_URL = BASE_URL;
    const UPLOAD_BASE = BASE_URL;

    const LOBBY_ROOM = "room-123";
    const role = "B";

    const qs = new URLSearchParams(location.search);
    const resumeChatId = qs.get("chatId");

    let currentRoom = resumeChatId || LOBBY_ROOM;

    const roomLabelEl = document.getElementById("roomLabel");
    const roleLabelEl = document.getElementById("roleLabel");
    roleLabelEl.textContent = role;

    function updateRoomLabel() { roomLabelEl.textContent = currentRoom; }
    updateRoomLabel();

    const messagesEl = document.getElementById("messages");
    const statusEl = document.getElementById("status");
    const callStateEl = document.getElementById("callState");

    const inputEl = document.getElementById("msg");
    const sendBtn = document.getElementById("send");
    const fileEl = document.getElementById("file");
    const uploadBtn = document.getElementById("uploadBtn");

    const answerBtn = document.getElementById("answerBtn");
    const hangupBtn = document.getElementById("hangupBtn");
    const remoteAudio = document.getElementById("remoteAudio");

    function setStatus(text) { statusEl.textContent = text; }
    function setCallState(text) { callStateEl.textContent = text; }
    function formatTime(ts) { return new Date(ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }); }

    function addBubble(side, text, ts = Date.now()) {
      const bubble = document.createElement("div");
      bubble.className = `bubble ${side}`;

      const body = document.createElement("div");
      body.textContent = text;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = formatTime(ts);

      bubble.appendChild(body);
      bubble.appendChild(meta);

      messagesEl.appendChild(bubble);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function addMediaGroup(side, media, ts = Date.now()) {
      const group = document.createElement("div");
      group.className = `group ${side}`;

      const voice = document.createElement("div");
      voice.className = `bubble ${side} inGroup`;

      const title = document.createElement("div");
      title.className = "title";
      title.textContent = media.title || "Voice message";

      const audio = document.createElement("audio");
      audio.controls = true;
      audio.preload = "none";
      audio.src = media.audioUrl;

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = formatTime(ts);

      voice.appendChild(title);
      voice.appendChild(audio);
      voice.appendChild(meta);
      group.appendChild(voice);

      if (media.transcript) {
        const tr = document.createElement("div");
        tr.className = `bubble ${side} inGroup`;

        const details = document.createElement("details");
        details.className = "tx";

        const summary = document.createElement("summary");
        summary.textContent = "Transcript";

        const t = document.createElement("div");
        t.className = "transcript";
        t.textContent = media.transcript;

        details.appendChild(summary);
        details.appendChild(t);

        tr.appendChild(details);
        group.appendChild(tr);
      }

      messagesEl.appendChild(group);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function addEmailCard(side, email, ts = Date.now()) {
      const group = document.createElement("div");
      group.className = `group ${side}`;

      const card = document.createElement("div");
      card.className = `bubble ${side} inGroup emailCard`;

      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `${email.icon || "ðŸ“§"} New email`;

      const headline = document.createElement("div");
      const subj = email.subject || "(no subject)";
      const sum = email.summary ? ` â€” ${email.summary}` : "";
      headline.textContent = subj + sum;

      const kv = document.createElement("div");
      kv.className = "kv";

      const from = document.createElement("div");
      from.textContent = `From: ${email.from || "-"}`;

      const date = document.createElement("div");
      date.textContent = `Date: ${email.date || "-"}`;

      kv.appendChild(from);
      kv.appendChild(date);

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.textContent = formatTime(ts);

      card.appendChild(title);
      card.appendChild(headline);
      card.appendChild(kv);
      card.appendChild(meta);

      group.appendChild(card);
      messagesEl.appendChild(group);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function clearMessages() { messagesEl.innerHTML = ""; }

    async function loadHistory(chatId) {
      if (!chatId) return;
      const resp = await fetch(`${BASE_URL}/sessions/${encodeURIComponent(chatId)}`);
      if (!resp.ok) return;
      const data = await resp.json();

      clearMessages();

      for (const ev of (data.events || [])) {
        if (ev.type !== "chat") continue;
        const side = (ev.from === role) ? "me" : "them";
        const ts = ev.ts || Date.now();

        let obj = null;
        try { obj = JSON.parse(ev.text); } catch {}

        if (obj?.type === "media" && typeof obj.audioUrl === "string") addMediaGroup(side, obj, ts);
        else if (obj?.type === "email") addEmailCard(side, obj, ts);
        else addBubble(side, ev.text, ts);
      }
    }

    function sendCurrent() {
      const text = inputEl.value.trim();
      if (!text) return;
      socket.emit("chat", { room: currentRoom, text });
      inputEl.value = "";
      inputEl.focus();
    }

    async function uploadSelectedFile() {
      if (!fileEl.files || fileEl.files.length === 0) return;

      uploadBtn.disabled = true;
      try {
        const fd = new FormData();
        fd.append("file", fileEl.files[0]);

        const resp = await fetch(`${UPLOAD_BASE}/upload`, { method: "POST", body: fd });
        if (!resp.ok) throw new Error(`Upload failed: HTTP ${resp.status}`);

        const out = await resp.json();
        socket.emit("chat", { room: currentRoom, text: `File uploaded: ${out.originalName}` });
      } catch (err) {
        addBubble("me", `Upload error: ${err.message}`);
      } finally {
        fileEl.value = "";
        uploadBtn.disabled = false;
      }
    }

    function callEndMessage(reason) {
      switch (reason) {
        case "rejected":  return "Call cancelled";
        case "canceled":  return "Call cancelled";
        case "no_answer": return "Missed call";
        case "ended":
        default:          return "Call ended";
      }
    }

    // ---- Socket.IO ----
    const socket = io(SERVER_URL, { transports: ["websocket", "polling"] });

    // ---- WebRTC (Customer callee) ----
    let pc = null;
    let localStream = null;
    let pendingIce = [];
    let incomingOffer = null;
    let inCall = false;

    const rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    function setCallUi(state) {
      if (state === "idle") {
        answerBtn.disabled = true;
        hangupBtn.disabled = true;
        setCallState("No call");
        inCall = false;
      } else if (state === "incoming") {
        answerBtn.disabled = false;
        hangupBtn.disabled = false;
        setCallState("Incoming callâ€¦");
        inCall = false;
      } else {
        answerBtn.disabled = true;
        hangupBtn.disabled = false;
        setCallState("In callâ€¦");
        inCall = true;
      }
    }

    async function ensurePeerConnection() {
      if (pc) return pc;

      pc = new RTCPeerConnection(rtcConfig);

      pc.onicecandidate = (event) => {
        if (event.candidate) socket.emit("call:ice", { room: currentRoom, candidate: event.candidate });
      };

      pc.ontrack = (event) => {
        if (event.streams && event.streams[0]) remoteAudio.srcObject = event.streams[0];
      };

      return pc;
    }

    async function startLocalAudio() {
      if (localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return localStream;
    }

    async function addLocalTracks() {
      const pc = await ensurePeerConnection();
      const stream = await startLocalAudio();
      stream.getTracks().forEach((t) => pc.addTrack(t, stream));
    }

    function cleanupCall() {
      incomingOffer = null;
      setCallUi("idle");

      if (pc) { pc.close(); pc = null; }
      if (localStream) { localStream.getTracks().forEach((t) => t.stop()); localStream = null; }

      pendingIce = [];
      remoteAudio.srcObject = null;
    }

    socket.on("call:offer", ({ sdp } = {}) => {
      if (!sdp) return;
      incomingOffer = sdp;
      setCallUi("incoming");
      addBubble("them", "Incoming callâ€¦");
    });

    answerBtn.addEventListener("click", async () => {
      try {
        if (!incomingOffer) return;
        if (currentRoom === LOBBY_ROOM) {
          addBubble("me", "Wait for session to start before answering.");
          return;
        }

        setCallUi("inCall");

        await ensurePeerConnection();
        await pc.setRemoteDescription(incomingOffer);
        await addLocalTracks();

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        socket.emit("call:answer", { room: currentRoom, sdp: pc.localDescription });

        for (const c of pendingIce) await pc.addIceCandidate(c);
        pendingIce = [];
      } catch (e) {
        addBubble("me", `Answer failed: ${e.message}`);
        cleanupCall();
      }
    });

    hangupBtn.addEventListener("click", () => {
      const reason = (incomingOffer && !inCall) ? "rejected" : "ended";
      socket.emit("call:hangup", { room: currentRoom, reason });
      cleanupCall();
      addBubble("them", callEndMessage(reason));
    });

    socket.on("call:ice", async ({ candidate } = {}) => {
      try {
        if (!candidate) return;
        if (!pc || !pc.remoteDescription) { pendingIce.push(candidate); return; }
        await pc.addIceCandidate(candidate);
      } catch (e) {
        addBubble("me", `ICE error: ${e.message}`);
      }
    });

    socket.on("call:hangup", ({ reason } = {}) => {
      cleanupCall();
      addBubble("them", callEndMessage(reason || "ended"));
    });

    socket.on("session:started", async ({ chatId } = {}) => {
      if (!chatId) return;
      currentRoom = chatId;
      updateRoomLabel();
      socket.emit("join", { room: currentRoom, role });
      await loadHistory(currentRoom);
    });

    socket.on("connect", async () => {
      setStatus("Connected");
      socket.emit("join", { room: currentRoom, role });
      setCallUi("idle");
      if (resumeChatId) await loadHistory(resumeChatId);
    });

    socket.on("disconnect", () => setStatus("Disconnected"));

    socket.on("connect_error", (err) => {
      setStatus("Connect error: " + (err?.message || err));
      console.log("connect_error:", err);
    });

    // ---- Chat rendering ----
    socket.on("chat", (m) => {
      const side = (m.from === role) ? "me" : "them";
      const ts = m.ts || Date.now();

      let obj = null;
      try { obj = JSON.parse(m.text); } catch {}

      if (obj?.type === "media" && typeof obj.audioUrl === "string") addMediaGroup(side, obj, ts);
      else if (obj?.type === "email") addEmailCard(side, obj, ts);
      else addBubble(side, m.text, ts);
    });

    sendBtn.addEventListener("click", sendCurrent);
    inputEl.addEventListener("keydown", (e) => { if (e.key === "Enter") sendCurrent(); });

    uploadBtn.addEventListener("click", () => fileEl.click());
    fileEl.addEventListener("change", uploadSelectedFile);
  </script>
</body>
</html>
